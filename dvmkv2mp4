#!/bin/bash
VERSION=v0.5.0-dev

## Which Languages of Audio and Sub tracks to keep in resulting mp4, if no match then all will be kept
LANGS="ALL"
## Whether to create audio-subs-meta mkv file having all streams except video to preserve TrueHD Atmos and such for future conversion back to original
ASM="no"
## Whether to delete source material after conversion
REMOVESOURCE="no"
## Whether to allow debug by keeping conversion data
DEBUG="no"
## Check OSTYPE and set ionice level to idle to not hammer disks during conversion
ADDSUBS="no"
## Whether to add subs to mp4 file default no as some bad subs can break the encoding"
SRC_FORMAT="mkv"
## Default input source container used for conversion
DST_SUFFIX="DV-MP4"
## Directory to store created files in, disabled (empty) by default. When specified and TEMP_DIR is not, this will also be used for temporary files.
DEST_DIR=""
## Directory to store temporary files in. Defaults to current directory. Script will create a 'tmp' subfolder in this directory for its temporary files.
TEMP_DIR=""
## Wether to create the lock file in the temporary directory. This can be useful when the source directory is read-only.
LOCK_IN_TEMP='no'

if [[ $OSTYPE == 'darwin'* ]]
then
  ionc="ionice --low"
  sed="gsed"
else
  ionc="ionice -c 3"
  sed="sed"
fi

HEADER="dvmkv2mp4 $VERSION - easily convert Dolby Vision or HDR10+ mkvs to Dolby Vision MP4 
Created by github.com/gacopl, Released under GPLv3
"
created_tag="Created with dvmkv2mp4 $@ ($VERSION)"

function print_help {
  echo "$HEADER"
  echo "-l | --langs          - filter audio and subtitle tracks by lang comma separated if not hit by filter keep all tracks "
  echo "-c | --ext-compat     - for extended device compatiblity ALWAYS FAKE target DV profile to be 5 (for APPLE/LG C7,8,9 and more) "
  echo "-a | --asm            - create audio-subs-meta mkv file"
  echo "-r | --remove-source  - remove source video after conversion"
  echo "-s | --add-subs       - add srt subtitles to mp4 as subtitle tracks"
  echo "-d | --debug          - keep intermediary conversion files"
  echo "-m | --mp4-source     - enable convert from MP4 source mode instead of MKV"
  echo "-f | --override-type  - override detected source type to one of dv5,dv7,dv8,hdr10plus"
  echo "--dest-dir            - destination directory (optional)"
  echo "--temp-dir            - directory for temporary files (optional), defaults to --dest-dir or working directory. Creates a 'tmp' subfolder."
  echo "--lock-in-temp        - create lock file in temporary directory instead of working directory"
  echo "-v | --version        - print version"
  echo ""
  echo "dvmkv2mp4 -l und,pol,eng -r -a # will process any DV/HDR10+ mkvs found in current dir and keep only Undefined, Polish and English tracks, will remove source file once done and will create audio-subs-meta file for future needs"
}

TEMP=$(getopt -o acl:rsdmf:vh --long asm,ext-compat,langs:,remove-source,add-subs,debug,mp4-source,override-type:,version,help,dest-dir:,temp-dir:,lock-in-temp \
              -n 'dvmkv2mp4' -- "$@")

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"



while true; do
  case "$1" in
    -v | --version ) echo "$HEADER"; shift; exit ;;
    -d | --debug ) DEBUG="yes"; shift ;;
    -a | --asm ) ASM="yes"; shift ;;
    -r | --remove-source ) REMOVESOURCE="yes"; shift ;;
    -s | --add-subs ) ADDSUBS="yes"; shift ;;
    -c | --ext-compat ) EXT_COMPAT="yes"; shift ;;
    -h | --help ) print_help; shift; exit ;;
    -m | --mp4-source ) SRC_FORMAT="mp4"; shift ;;
    -f | --override-type ) SRC_TYPE="$2"; shift 2 ;;
    -l | --langs ) LANGS="$2"; shift 2 ;;
    --dest-dir ) DEST_DIR="$2"; shift 2 ;;
    --temp-dir ) TEMP_DIR="$2"; shift 2 ;;
    --lock-in-temp ) LOCK_IN_TEMP='yes'; shift ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done

function cleanup {
  if [ $DEBUG != "yes" ]; then
    while read i;do
      rm "`echo "$i" | cut -f1 -d\|`"
    done <<< "$(cat "${TEMP_DIR}audio.exports")"

    rm "${TEMP_DIR}RPU.bin" "${TEMP_DIR}extra.json" "${TEMP_DIR}hdr10plus_metadata.json"
    rm "${TEMP_DIR}audio.exports"
    rm "${TEMP_DIR}sub.exports"
    rm "${TEMP_DIR}tracks.list"
    rm "${TEMP_DIR}chapters.list"
    rm "${TEMP_DIR}BL"*"hevc"

    if [ $exit_code -eq 0 ]; then
      if [ $REMOVESOURCE == "yes" ]; then
        echo ""
        echo "Removing source as requested"
        rm "${input}"
        if [[ "${input}" == *"${DST_SUFFIX}.mp4" ]]; then
          # Move back files to original naming if source already had SUFFIX 
          echo "Renaming converted files to original source names"
          mv "${output}.mp4" "${input}"
          mv "${output}.nfo" "${inputbase}.nfo"
          for filename in "${inputbase}".mp4.*.*; do
            if [ -e "$filename" ]; then
              new_filename=$(echo "$filename" | sed 's/\.mp4\.[^.]*\.[^.]*$//')
              mv "$filename" "$new_filename"
            fi
          done
        fi
      fi
    else
      echo "Conversion FAILED keeping the source and SRT subtitles, deleting rest"
      for i in "$output"*.{srt}; do 
        cp "$i" "${inputbase}$(echo "$i" | sed -n 's/.*\(\.[^.]*\.\(srt\|sup\)\)$/\1/p')"
        echo "${inputbase}$(echo "$i" | sed -n 's/.*\(\.[^.]*\.\(srt\|sup\)\)$/\1/p')"
      done
      rm "${output}.nfo" "${output}.asm" "${output}.*.srt" "${output}.*.sup"
    fi
  fi 
}

function processsubs {
    ### PROCESS SUBS
    # Only copy SRT if we are changing filename suffix
    if [[ "$inputbase" != *"${DST_SUFFIX}.mp4" ]]; then
      for i in "$inputbase"*.srt; do 
        cp "$i" "${output}$(echo "$i" | sed -n 's/.*\(\.[^.]*\.srt\)$/\1/p')"
      done
    fi
    # CONVERT PGS 2 SRT
    if [ -s "${TEMP_DIR}sub.exports" ] && [ "$(cat "${TEMP_DIR}sub.exports" | grep hdmv_pgs)" != "" ]; then
      while read i;do
        stream=`echo "$i" | cut -f1 -d\|`
        id=`echo "$i" | cut -f2 -d\|`
        codec=`echo "$i" | cut -f3 -d\|`
        orig_codec=`echo "$i" | cut -f4 -d\|`
        delay=`echo "$i" | cut -f5 -d\|`
        lang=`echo "$i" | cut -f6 -d\|`
        title=`echo "$i" | cut -f7 -d\|`
        /opt/dotnet/dotnet /opt/PgsToSrt/net6/PgsToSrt.dll --input "$stream" --output "${stream%.sup}.srt" --tesseractlanguage=$lang
        echo "${stream%.sup}.srt|$id|srt|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
        #docker run --rm -v "`pwd`":/data -e INPUT="/data/$stream" -e OUTPUT="/data/${stream%.sup}.srt" -e LANGUAGE=$lang tentacule/pgstosrt
      done <<< "$(cat "${TEMP_DIR}sub.exports" | grep hdmv_pgs)"
    fi
}

# Directory checks
if [ -n "$DEST_DIR" ]; then
  # Remove trailing slash if present, then add it so trailing slash is always present
  DEST_DIR="${DEST_DIR%/}/"
  if [ ! -d "$DEST_DIR" ]; then
      echo "ERROR: dest-dir option value '$DEST_DIR' is not a directory"
      exit 1
  fi
else
  DEST_DIR=""
fi

TEMP_DIR_SUBFOLDER='tmp'
if [ -n "$TEMP_DIR" ]; then
  # Remove trailing slash if present, then add it so trailing slash is always present
  TEMP_DIR="${TEMP_DIR%/}/${TEMP_DIR_SUBFOLDER}/"
elif [ -n "$DEST_DIR" ]; then
  TEMP_DIR="${DEST_DIR}${TEMP_DIR_SUBFOLDER}/"
else
  TEMP_DIR="./${TEMP_DIR_SUBFOLDER}/"
fi
TEMP_DIR_CREATED=''
if [ ! -d "$TEMP_DIR" ]; then
  mkdir "$TEMP_DIR"
  if [ $? -ne 0 ]; then
    echo "ERROR: unable to create temporary directory '$TEMP_DIR'"
    exit 1
  fi
  TEMP_DIR_CREATED='yes'
fi

if [ "$LOCK_IN_TEMP" = 'yes' ]; then
  LOCKFILE="${TEMP_DIR}.dvconverting"
else
  LOCKFILE=".dvconverting"
fi
if [ -f "${LOCKFILE}" ]; then
  echo "Already converting"
  exit 1
fi
touch "${LOCKFILE}"

start=`date +%s`
echo "$HEADER"
echo "Starting Conversions `date`"
echo "----------------------------"
for f in *.${SRC_FORMAT};do
  echo ""
  echo "-------------"
  echo "IN:  $f"
  input="$f"
  inputbase=${input%.${SRC_FORMAT}}
  ffprobe_source_info=$(ffprobe "$input" 2>&1 | grep DOVI | grep -v comment | sed s/://g)
  short_info=$(mediainfo "$input" |awk '/Text #1/{exit}1' | grep -i "^video\|^audio\|format\|commercial\|lang\|title" | cut -f2 -d":" | sed s/,//g | sed s/^Video/\ \|\ Video\ -\ /g | sed s/^Audio/\ \|\ Audio\ -\ /g)
  dv=$(mediainfo "$input" | grep 'HDR format.*Dolby Vision')
  hdr10plus=$(mediainfo "$input" | grep 'HDR format.*HDR10+')
  output=`echo "$input" | $sed "s/\ DV.${SRC_FORMAT}\|\ HDR10+.${SRC_FORMAT}\|\ HDR.${SRC_FORMAT}/.${SRC_FORMAT}/g" | $sed s/\.${SRC_FORMAT}/\ ${DST_SUFFIX}\.${SRC_FORMAT}/g | $sed "s/\ ${DST_SUFFIX} ${DST_SUFFIX}\.${SRC_FORMAT}/\ ${DST_SUFFIX}\.${SRC_FORMAT}/g"`
  output="${DEST_DIR}${output%.${SRC_FORMAT}}"
  if [[ "${SRC_FORMAT}" == "mp4" ]]; then
    if [[ $input == *"${DST_SUFFIX}.mp4.mp4" ]]; then
      echo "Input and output would be the same and input already .mp4.mp4 ABORTING!!!"
      continue
    elif [[ $input == *"${DST_SUFFIX}.mp4" ]]; then
      output="${DEST_DIR}${output}.mp4"
    fi
  fi
  echo "OUT: ${output}.mp4"
  echo "TEMP: $TEMP_DIR"
  echo ""

  ffstart5_8="$ionc ffmpeg -i \"$input\" -y -loglevel error -stats -map 0:0 -c:v copy -vbsf hevc_mp4toannexb -f hevc \"${TEMP_DIR}BL_RPU.hevc\""
  ffstart7_1="$ionc ffmpeg -i \"$input\" -y -loglevel error -stats -map 0:0 -c:v copy -vbsf hevc_mp4toannexb -f hevc -"
  ffstart7_2="$ionc ffmpeg -i \"$input\" -y -loglevel error -stats -map 0:v:0 -c:v copy -vbsf hevc_mp4toannexb -f hevc \"${TEMP_DIR}BL.hevc\" -map 0:v:1 -c:v copy -vbsf hevc_mp4toannexb -f hevc -"
  ffend7_1="| $ionc dovi_tool -m 2 convert --discard -o \"${TEMP_DIR}BL_RPU.hevc\" -"
  ffend7_2="| $ionc dovi_tool -m 2 extract-rpu - -o \"${TEMP_DIR}RPU.bin\""
  ffstarthdr10plus="$ionc ffmpeg -i \"$input\" -y -loglevel error -stats -map 0:v:0 -c:v copy -vbsf hevc_mp4toannexb -f hevc \"${TEMP_DIR}BL.hevc\" -map 0:v:0 -c:v copy -vbsf hevc_mp4toannexb -f hevc -"
  ffendhdr10plus="| $ionc hdr10plus_tool extract -o \"${TEMP_DIR}hdr10plus_metadata.json\" -"

  ## AUTODETECT SOURCE TYPE AND CONSTRUCT FFMPEG
  if [ -z "$hdr10plus" ] && [ -z "$dv" ]; then
    echo "Not an HDR10+ nor DV source"
    continue
  else
    if [ ! -z "$dv" ]; then
      if [[ "$SRC_TYPE" != "" ]]; then
        source_type_msg="Source Type overriden to $SRC_TYPE !!!"
        echo "$source_type_msg"
        created_tag+=" | $source_type_msg"
        dv_profile=$SRC_TYPE
      else
        dv_profile=$(mediainfo "$input" | grep "HDR format.*dvhe\." | $sed 's/.*dvhe\.0\(.\).*/\1/')
        if ! [[ $dv_profile =~ ^[0-9]+$ ]]; then
          echo "Could not recognize Dolby Vision Profile in source - ABORTING"
          echo "Please use -f switch to set profile manually (dv5,dv7,dv8.1,dv8.2,dv8.4)"
          continue
        fi
        if { [ "$dv_profile" -ne 4 ] && [ "$dv_profile" -ne 5 ] && [ "$dv_profile" -ne 7 ] && [ "$dv_profile" -ne 8 ]; } ; then
          info "Unsupported Dolby Vision profile '$dv_profile'; doing nothing"
          continue
        fi
      fi
      vscount=`ffprobe -loglevel error -select_streams v -show_entries stream=type:stream=codec_name:stream=index:stream_tags=language:stream_tags=title -of csv=p=0 "$input" | grep hevc | wc -l`
      if [ "$dv_profile" -eq 4 ] || [ "$dv_profile" -eq 5 ] || [ "$dv_profile" -eq 8 ];then
        ffstring=("$ffstart5_8")
      elif [ "$dv_profile" -eq 7 ] && [ "$vscount" -eq 1 ];then
        ffstring=("$ffstart7_1")
      else
        ffstring=("$ffstart7_2")
      fi
      if [ "$dv_profile" -eq 5 ]; then
        dv_target=5
      elif [ "$dv_profile" -eq 4 ]; then
        dv_target=4
      else
        dv_target=8.1
      fi
      echo "Converting DV$dv_profile $SRC_FORMAT to DV$dv_target mp4"
      echo
      created_tag+=" | Source - DV$dv_profile $ffprobe_source_info | $short_info"
    elif [ ! -z "$hdr10plus" ]; then
      echo "Converting HDR10+ $SRC_FORMAT to DV8"
      echo
      created_tag+=" | Source - HDR10+ $ffprobe_source_info | $short_info"
      dv_target=8.1
      ffstring=("$ffstarthdr10plus")
      MaxDML=`mediainfo "$input" | grep 'Mastering display luminance' | cut -f 4 -d:`
      MaxDML=${MaxDML% cd*}
      MaxDML=${MaxDML%.*}
      MinDML=`mediainfo "$input" | grep 'Mastering display luminance' | cut -f 3 -d:`
      MinDML=${MinDML% cd*}
      if [ "$MinDML" == " 0.0050" ]; then 
        MinDML=50 
      elif [ "$MinDML" == " 0.0010" ]; then
        MinDML=10  
      else
        MinDML=1  
      fi
      MaxFALL=`mediainfo "$input" | grep 'Maximum Frame-Average Light Level' | cut -f 2 -d: | cut -f2 -d" "`
      MaxCLL=`mediainfo "$input" | grep 'Maximum Content Light Level' | cut -f 2 -d: | cut -f2 -d" "`
      ## Fake HDR10 Metadata if missing on source as it's only needed for backwards hdr10 compatibility but will play fine in DV
      if [ -z "$MaxDML" ]; then 
        MaxDML=1000;
      fi
      if [ -z "$MinDML" ]; then 
        MinDML=1;
      fi
      if [ -z "$MaxFALL" ]; then 
        MaxFALL=500;
      fi
      if [ -z "$MaxCLL" ]; then 
        MaxCLL=1000;
      fi
      FrameCount=`mediainfo --Inform='Video;%FrameCount%' "$input"`
      cat > "${TEMP_DIR}extra.json" <<EOF
{
"cm_version": "V29",
"length": $FrameCount,
    "level6": {
        "max_display_mastering_luminance": $MaxDML,
        "min_display_mastering_luminance": $MinDML,
        "max_content_light_level": $MaxCLL,
        "max_frame_average_light_level": $MaxFALL
    }
}
EOF
    fi
  fi
  # SELECT LANG TRACKS
  as=$(ffprobe -loglevel error -select_streams a -show_entries stream=type:stream=codec_name:stream=index:stream=start_pts:stream_tags=language:stream_tags=title -of csv=p=0 "$input" | grep $(echo $LANGS | $sed 's/,/\\|,.*,.*,/g' | $sed 's/^/,.*,.*,/') | $sed 's/,/\|/g' )
  if [ "$as" == "" ]; then
    ffprobe -loglevel error -select_streams a -show_entries stream=type:stream=codec_name:stream=index:stream=start_pts:stream_tags=language:stream_tags=title -of csv=p=0 "$input" | $sed 's/,/\|/g' > "${TEMP_DIR}tracks.list"
  else
    echo "$as" > "${TEMP_DIR}tracks.list"
  fi
  ts=$(ffprobe -loglevel error -select_streams s -show_entries stream=type:stream=codec_name:stream=index:stream=start_pts:stream_tags=language:stream_tags=title -of csv=p=0 "$input" | grep $(echo $LANGS | $sed 's/,/\\|,.*,.*,/g' | $sed 's/^/,.*,.*,/') | $sed 's/,/\|/g' )
  if [ "$ts" == "" ]; then
    ffprobe -loglevel error -select_streams s -show_entries stream=type:stream=codec_name:stream=index:stream=start_pts:stream_tags=language:stream_tags=title -of csv=p=0 "$input" | $sed 's/,/\|/g' >> "${TEMP_DIR}tracks.list"
  else
    echo "$ts" >> "${TEMP_DIR}tracks.list"
  fi
  
  # FFMPEG PROCESS TRACKS
  while read i;do
    id=`echo "$i" | cut -f1 -d\|`
    orig_codec=`echo "$i" | cut -f2 -d\|`
    delay=`echo "$i" | cut -f3 -d\|`
    lang=`echo "$i" | cut -f4 -d\|`
    # cover case of missing lang metadata
    valid="[a-za-za-z]"
    if [[ ! $lang =~ $valid ]]; then 
      lang="und";
      title=`echo "$i" | cut -f4 -d\|`
    else
      title=`echo "$i" | cut -f5 -d\|`
    fi
    title="${title//[\"\',\`]/}"
    ffopts=""
    if [ "$orig_codec" == "truehd" ]; then
      ffopts="-map 0:$id -b:a:0 1024k -c:a:0 eac3 -f eac3 \"${TEMP_DIR}$id.$lang.eac3\""
      echo "${TEMP_DIR}$id.$lang.eac3|$id|eac3|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "eac3" ]; then
      ffopts="-map 0:$id -c:a:0 copy \"${TEMP_DIR}$id.$lang.eac3\""
      echo "${TEMP_DIR}$id.$lang.eac3|$id|eac3|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "dts" ]; then
      ffopts="-map 0:$id -b:a:0 1024k -c:a:0 eac3 -f eac3 \"${TEMP_DIR}$id.$lang.eac3\""
      echo "${TEMP_DIR}$id.$lang.eac3|$id|eac3|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "ac3" ]; then
      ffopts="-map 0:$id -c:a:0 copy \"${TEMP_DIR}$id.$lang.ac3\""
      echo "${TEMP_DIR}$id.$lang.ac3|$id|ac3|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "aac" ]; then
      ffopts="-map 0:$id -c:a:0 copy \"${TEMP_DIR}$id.$lang.aac\""
      echo "${TEMP_DIR}$id.$lang.aac|$id|aac|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "mp3" ]; then
      ffopts="-map 0:$id -c:a:0 copy \"${TEMP_DIR}$id.$lang.mp3\""
      echo "${TEMP_DIR}$id.$lang.mp3|$id|mp3|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}audio.exports"
    fi
    if [ "$orig_codec" == "ass" ]; then
      ffopts="-map 0:$id -c:s:0 copy \"$output.${lang}${id}.ass\" -map 0:$id -c:s:0 srt \"$output.${lang}${id}.srt\""
      echo "$output.${lang}${id}.ass|$id|ass|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
      echo "$output.${lang}${id}.srt|$id|srt|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
    fi
    if [ "$orig_codec" == "mov_text" ]; then
      ffopts="-map 0:$id -c:s:0 srt \"$output.${lang}${id}.srt\""
      echo "$output.${lang}${id}.srt|$id|srt|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
    fi
    if [ "$orig_codec" == "srt" ] || [ "$orig_codec" == "subrip" ]; then
      ffopts="-map 0:$id -c:s:0 copy \"$output.${lang}${id}.srt\""
      echo "$output.${lang}${id}.srt|$id|srt|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
    fi
    if [ "$orig_codec" == "hdmv_pgs_subtitle" ]; then
      ffopts="-map 0:$id -c:s:0 copy \"$output.${lang}${id}.sup\""
      echo "$output.${lang}${id}.sup|$id|hdmv_pgs_subtitles|$orig_codec|$delay|$lang|$title" >> "${TEMP_DIR}sub.exports"
    fi
    ffstring+=($ffopts)
  done <<< "$(cat "${TEMP_DIR}tracks.list")"
  
  if [ $ASM == "yes" ]; then
    # FFMPEG TRACKS FOR ASM
    while read i;do
      id=`echo "$i" | cut -f1 -d\|`
      ffopts="-map 0:$id"
      ffstring+=($ffopts)
    done <<< "$(cat "${TEMP_DIR}tracks.list")"
    ffstring+=("-c copy -f matroska \"${output}.asm\"")
  fi
  
  # FFMPEG HANDLE METADATA INJECTION
  if [ ! -z "$dv" ]; then
    # HANDLE DV METADATA
    if [ "$dv_profile" -eq 7 ] && [ "$vscount" -eq 1 ];then
      ffstring+=("$ffend7_1")
      echo ${ffstring[*]}
      eval ${ffstring[*]}
    elif [ "$dv_profile" -eq 7 ] && [ "$vscount" -eq 2 ];then
      ffstring+=("$ffend7_2")
      echo ${ffstring[*]}
      eval ${ffstring[*]}
      $ionc dovi_tool inject-rpu -i "${TEMP_DIR}BL.hevc" --rpu-in "${TEMP_DIR}RPU.bin" -o "${TEMP_DIR}BL_RPU.hevc"
      rm "${TEMP_DIR}BL.hevc" "${TEMP_DIR}RPU.bin"
    else
      echo ${ffstring[*]}
      eval ${ffstring[*]}
    fi
    ### PROCESS SUBS
    processsubs
  elif [ ! -z "$hdr10plus" ]; then
    # HANDLE HDR10+ METADATA
    ffstring+=("$ffendhdr10plus")
    echo ${ffstring[*]}
    eval ${ffstring[*]}

    ### PROCESS SUBS
    processsubs

    ### VERIFY HDR10+ METADATA
    MetadataCount=`cat "${TEMP_DIR}hdr10plus_metadata.json" | jq -r '.SceneInfo | length'`
    MetadataPercent=`bc <<< "scale=2; $MetadataCount/$FrameCount * 100"`
    MetadataPercent=${MetadataPercent%.*}
    if [ "$MetadataPercent" -gt 95 ]; then 
      echo "Metadata seems ok proceeding"
      $ionc dovi_tool generate -j "${TEMP_DIR}extra.json" --hdr10plus-json "${TEMP_DIR}hdr10plus_metadata.json" -o "${TEMP_DIR}RPU.bin"
      $ionc dovi_tool inject-rpu -i "${TEMP_DIR}BL.hevc" --rpu-in "${TEMP_DIR}RPU.bin" -o "${TEMP_DIR}BL_RPU.hevc"
      rm "${TEMP_DIR}BL.hevc"
    else 
      echo "Invalid HDR10+ Metadata ABORTING"
      echo "HDR10+ Metadata Frames: $MetadataCount VideoFrames: $FrameCount  $MetadataPercent%"
      echo
      exit_code=-1
      cleanup
      continue
    fi
  fi


  ### GRAB CHAPTERS
  if [[ "$SRC_FORMAT" == "mp4" ]]; then
    MP4Box -dump-chap-ogg "${input}" -std > "${TEMP_DIR}chapters.list"
  else
    mkvextract chapters -s "${input}" > "${TEMP_DIR}chapters.list"
  fi

  ### FINAL COMPOSITION
  if [[ "$EXT_COMPAT" == "yes" && $dv_target != "5" ]]; then
    echo
    echo "Faking DV$dv_target to DV5 for extended device compatiblity"
    echo
    dv_target=5
  fi
  
  mp4string=("$ionc MP4Box -add \"${TEMP_DIR}BL_RPU.hevc\":dvp=${dv_target}:hdr=none")
  tcount=2
  while read i;do
    stream=`echo "$i" | cut -f1 -d\|`
    id=`echo "$i" | cut -f2 -d\|`
    codec=`echo "$i" | cut -f3 -d\|`
    orig_codec=`echo "$i" | cut -f4 -d\|`
    delay=`echo "$i" | cut -f5 -d\|`
    lang=`echo "$i" | cut -f6 -d\|`
    title=`echo "$i" | cut -f7 -d\|`
    mp4opts="-add \"$stream\":sopt:gfreg=ffdmx -lang $tcount=$lang -name $tcount=\"$title\" -delay $tcount=$delay"
    mp4string+=($mp4opts)
    tcount=$((tcount+1))
  done <<< "$(cat "${TEMP_DIR}audio.exports")"
  
  if [ $ADDSUBS == "yes" ]; then
    echo "Below subtitles will be added to output file"
    while read i;do
      stream=`echo "$i" | cut -f1 -d\|`
      id=`echo "$i" | cut -f2 -d\|`
      codec=`echo "$i" | cut -f3 -d\|`
      orig_codec=`echo "$i" | cut -f4 -d\|`
      delay=`echo "$i" | cut -f5 -d\|`
      lang=`echo "$i" | cut -f6 -d\|`
      title=`echo "$i" | cut -f7 -d\|`
      echo $stream
      if [ "$codec" == "srt" ] && [ -s "$stream" ]; then
        mp4opts="-add \"$stream\":lang=$lang:name=\"$title\" -delay $tcount=$delay"
        mp4string+=($mp4opts)
        tcount=$((tcount+1))
      fi
    done <<< "$(cat "${TEMP_DIR}sub.exports")"
  fi

  if [ -s "${TEMP_DIR}chapters.list" ]; then
    mp4string+=("-chap \"${TEMP_DIR}chapters.list\"")
  fi

  echo ""
  echo "Muxing to output file"
  echo ""
  mp4string+=("-tmp \"${TEMP_DIR}\" -brand mp42isom -ab dby1 -tags comment=\"${created_tag}\" -new \"$output.mp4\"")
  echo ${mp4string[*]}
  eval ${mp4string[*]}
  exit_code=$?

  # Preparing NFO
  ffprobe_output_info=$(ffprobe "${output}.mp4" 2>&1 | grep DOVI | grep -v comment | sed s/://g)
  echo "Created with dvmkv2mp4 $@ ($VERSION)" > "${output}.nfo"
  echo "$source_type_msg" >> "${output}.nfo"
  echo "--------- SOURCE ------------" >> "${output}.nfo"
  echo $ffprobe_source_info >> "${output}.nfo"
  mediainfo "${input}" >> "${output}.nfo"
  echo "--------- TARGET ------------" >> "${output}.nfo"
  echo $ffprobe_output_info >> "${output}.nfo"
  mediainfo "${output}.mp4" >> "${output}.nfo"
  
  cleanup  
  coment_tag=""
  echo "-------------"
done

rm "${LOCKFILE}"

if [ "$TEMP_DIR_CREATED" = 'yes' ]; then
  rmdir "${TEMP_DIR}"
fi

end=`date +%s`
runtime=$((end-start))
hours=$((runtime / 3600)); minutes=$(( (runtime % 3600) / 60 )); seconds=$(( (runtime % 3600) % 60 )); 
echo ""
echo "-------------------------------"
echo "Conversions runtime: $hours:$minutes:$seconds (hh:mm:ss)"
echo